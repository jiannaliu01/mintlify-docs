---
title: "EHR Integration"
description: "Automatically populate structured EHR fields"
---

## TLDR

This tutorial shows you how to build an AI-powered EHR integration system that can intelligently split mixed medical documents and extract structured data. First, use Cardinal's `/split` endpoint to separate different document types (patient intake forms, insurance cards, consent forms), then apply targeted `/extract` schemas to each section for precise EHR data entry.

---

## Building Your EHR Integration System

Let's build a practical EHR integration system that can handle mixed medical documents - like when a patient submits their intake form, insurance card, and consent form all in one PDF.

### 0) Install dependencies

```python
# Install dependencies
!pip install -q requests python-dotenv pandas tqdm
```

### 1) Load environment variables

```python
from google.colab import drive
drive.mount('/content/drive')

import os, dotenv
dotenv.load_dotenv('/content/drive/MyDrive/.env')

# Cardinal API
CARDINAL_URL = os.getenv("CARDINAL_URL", "https://api.trycardinal.ai")
CARDINAL_API_KEY = os.getenv("CARDINAL_API_KEY")

# Verify API key is loaded
if not CARDINAL_API_KEY:
    print("Warning: CARDINAL_API_KEY not found in environment variables")
else:
    print("Cardinal API key loaded successfully")
```

### 2) Define Document Splitting Queries

First, let's define what types of medical documents we want to split:

```python
import json

# Define queries for splitting medical documents
MEDICAL_DOCUMENT_QUERIES = [
    {
        "name": "patient_intake",
        "description": "Patient intake forms with personal information, medical history, symptoms, medications, and demographics"
    },
    {
        "name": "insurance_cards", 
        "description": "Insurance cards with member ID, group number, plan information, and insurance company details"
    },
    {
        "name": "consent_forms",
        "description": "Consent forms, HIPAA authorizations, treatment agreements, and signature pages"
    },
    {
        "name": "referral_letters",
        "description": "Physician referral letters, medical recommendations, and provider-to-provider communications"
    }
]

print("Document splitting queries defined:")
for query in MEDICAL_DOCUMENT_QUERIES:
    print(f"  ‚Ä¢ {query['name']}: {query['description'][:60]}...")
```

### 3) Define EHR Schemas for Each Document Type

Now let's create targeted JSON schemas for each document type:

```python
# Schema for Patient Intake Forms
PATIENT_INTAKE_SCHEMA = {
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "title": "PatientIntakeForm",
    "type": "object",
    "properties": {
        "patient_demographics": {
            "type": "object",
            "properties": {
                "first_name": {"type": "string"},
                "last_name": {"type": "string"},
                "date_of_birth": {"type": "string"},
                "gender": {"type": "string"},
                "address": {
                    "type": "object",
                    "properties": {
                        "street": {"type": "string"},
                        "city": {"type": "string"},
                        "state": {"type": "string"},
                        "zip_code": {"type": "string"}
                    }
                },
                "phone_number": {"type": "string"},
                "email": {"type": "string"},
                "emergency_contact": {
                    "type": "object",
                    "properties": {
                        "name": {"type": "string"},
                        "relationship": {"type": "string"},
                        "phone": {"type": "string"}
                    }
                }
            }
        },
        "medical_history": {
            "type": "object",
            "properties": {
                "current_medications": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "medication_name": {"type": "string"},
                            "dosage": {"type": "string"},
                            "frequency": {"type": "string"}
                        }
                    }
                },
                "allergies": {
                    "type": "array",
                    "items": {"type": "string"}
                },
                "medical_conditions": {
                    "type": "array", 
                    "items": {"type": "string"}
                },
                "previous_surgeries": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "procedure": {"type": "string"},
                            "date": {"type": "string"}
                        }
                    }
                },
                "family_history": {
                    "type": "array",
                    "items": {
                        "type": "object", 
                        "properties": {
                            "condition": {"type": "string"},
                            "relationship": {"type": "string"}
                        }
                    }
                }
            }
        },
        "chief_complaint": {
            "type": "object",
            "properties": {
                "primary_symptoms": {"type": "string"},
                "symptom_duration": {"type": "string"},
                "pain_level": {"type": "integer", "minimum": 0, "maximum": 10},
                "additional_concerns": {"type": "string"}
            }
        }
    },
    "required": ["patient_demographics"]
}

# Schema for Insurance Cards
INSURANCE_CARD_SCHEMA = {
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "title": "InsuranceCard",
    "type": "object", 
    "properties": {
        "insurance_info": {
            "type": "object",
            "properties": {
                "insurance_company": {"type": "string"},
                "plan_name": {"type": "string"},
                "member_id": {"type": "string"},
                "group_number": {"type": "string"},
                "policy_holder_name": {"type": "string"},
                "effective_date": {"type": "string"},
                "copay_amounts": {
                    "type": "object",
                    "properties": {
                        "primary_care": {"type": "string"},
                        "specialist": {"type": "string"},
                        "emergency_room": {"type": "string"},
                        "urgent_care": {"type": "string"}
                    }
                },
                "deductible": {"type": "string"},
                "customer_service_phone": {"type": "string"},
                "provider_network": {"type": "string"}
            }
        },
        "coverage_details": {
            "type": "object",
            "properties": {
                "in_network_benefits": {"type": "string"},
                "out_of_network_benefits": {"type": "string"},
                "prescription_coverage": {"type": "string"},
                "mental_health_coverage": {"type": "string"}
            }
        }
    },
    "required": ["insurance_info"]
}

# Schema for Consent Forms
CONSENT_FORM_SCHEMA = {
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "title": "ConsentForm",
    "type": "object",
    "properties": {
        "consent_details": {
            "type": "object",
            "properties": {
                "patient_name": {"type": "string"},
                "consent_type": {"type": "string"},
                "procedure_or_treatment": {"type": "string"},
                "consent_date": {"type": "string"},
                "witness_name": {"type": "string"},
                "provider_name": {"type": "string"}
            }
        },
        "hipaa_authorization": {
            "type": "object",
            "properties": {
                "authorized_persons": {
                    "type": "array",
                    "items": {"type": "string"}
                },
                "information_to_disclose": {"type": "string"},
                "expiration_date": {"type": "string"},
                "patient_signature_date": {"type": "string"}
            }
        },
        "communication_preferences": {
            "type": "object",
            "properties": {
                "preferred_contact_method": {"type": "string"},
                "appointment_reminders": {"type": "boolean"},
                "test_results_delivery": {"type": "string"},
                "marketing_communications": {"type": "boolean"}
            }
        }
    },
    "required": ["consent_details"]
}

# Schema mapping for different document types
SCHEMA_MAPPING = {
    "patient_intake": PATIENT_INTAKE_SCHEMA,
    "insurance_cards": INSURANCE_CARD_SCHEMA, 
    "consent_forms": CONSENT_FORM_SCHEMA,
    "referral_letters": {  # Simple schema for referrals
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "title": "ReferralLetter",
        "type": "object",
        "properties": {
            "referring_provider": {"type": "string"},
            "patient_name": {"type": "string"},
            "referral_reason": {"type": "string"},
            "recommended_specialist": {"type": "string"},
            "urgency_level": {"type": "string"},
            "relevant_history": {"type": "string"}
        }
    }
}

print("EHR extraction schemas defined for:")
for doc_type in SCHEMA_MAPPING.keys():
    print(f"  ‚úì {doc_type}")
```

### 4) Document Splitting Functions

```python
import requests
from typing import Dict, Any, List, Optional

def split_medical_document(file_url: str, 
                          queries: List[Dict[str, str]] = None) -> Dict[str, Any]:
    """
    Split a mixed medical document into different types using Cardinal's /split endpoint.
    
    Args:
        file_url: Direct URL to the PDF file
        queries: List of query objects for document splitting
    
    Returns:
        Dictionary containing split results with pages for each document type
    """
    if queries is None:
        queries = MEDICAL_DOCUMENT_QUERIES
        
    url = f"{CARDINAL_URL.rstrip('/')}/split"
    
    # Prepare form data
    form_data = {
        "fileUrl": file_url,
        "queries": json.dumps(queries)
    }
    
    headers = {
        "x-api-key": CARDINAL_API_KEY
    }
    
    print(f"Splitting medical document: {file_url}")
    print(f"Looking for {len(queries)} document types...")
    
    try:
        response = requests.post(url, data=form_data, headers=headers, timeout=180)
        response.raise_for_status()
        
        result = response.json()
        
        if result.get("success"):
            print(f"‚úÖ Successfully split document into {len(result.get('partitions', []))} sections")
            
            # Print summary of what was found
            for partition in result.get("partitions", []):
                page_count = len(partition.get("pages", []))
                print(f"  üìÑ {partition['name']}: {page_count} pages {partition.get('pages', [])}")
                
            return {
                "success": True,
                "split_result": result
            }
        else:
            return {
                "success": False,
                "error": "Split operation failed",
                "raw_response": result
            }
            
    except requests.exceptions.RequestException as e:
        print(f"Request error during document split: {e}")
        return {"success": False, "error": str(e)}
    except Exception as e:
        print(f"Unexpected error during document split: {e}")
        return {"success": False, "error": str(e)}

def extract_from_document_section(file_url: str,
                                 schema: Dict[str, Any], 
                                 section_name: str,
                                 pages: List[int] = None,
                                 use_fast_mode: bool = False) -> Dict[str, Any]:
    """
    Extract structured data from a specific section of a document.
    
    Args:
        file_url: Direct URL to the PDF file
        schema: JSON schema for extraction
        section_name: Name of the document section being processed
        pages: List of page numbers to focus on (not directly supported by API yet)
        use_fast_mode: Use fast extraction mode
    
    Returns:
        Dictionary containing extracted structured data
    """
    url = f"{CARDINAL_URL.rstrip('/')}/extract"
    
    # Create context specific to the document section
    context_map = {
        "patient_intake": "Patient intake form with demographics, medical history, current symptoms, and medications",
        "insurance_cards": "Insurance card with member ID, group numbers, copay amounts, and coverage details", 
        "consent_forms": "Medical consent forms with HIPAA authorizations, signatures, and communication preferences",
        "referral_letters": "Medical referral letter from one provider to another with patient information and recommendations"
    }
    
    custom_context = context_map.get(section_name, f"Medical document section: {section_name}")
    if pages:
        custom_context += f". Focus on pages: {', '.join(map(str, pages))}"
    
    # Prepare form data
    form_data = {
        "fileUrl": file_url,
        "schema": json.dumps(schema),
        "fast": str(use_fast_mode).lower(),
        "customContext": custom_context
    }
    
    headers = {
        "x-api-key": CARDINAL_API_KEY
    }
    
    print(f"Extracting {section_name} data...")
    
    try:
        response = requests.post(url, data=form_data, headers=headers, timeout=180)
        response.raise_for_status()
        
        result = response.json()
        
        # Parse the response - it might be a string or object
        if isinstance(result.get("response"), str):
            extracted_data = json.loads(result["response"])
        else:
            extracted_data = result.get("response", {})
            
        return {
            "success": True,
            "section_name": section_name,
            "pages": pages,
            "data": extracted_data,
            "method": result.get("method", "unknown"),
            "pages_processed": result.get("pages_processed"),
            "raw_response": result
        }
        
    except requests.exceptions.RequestException as e:
        print(f"Request error during {section_name} extraction: {e}")
        return {"success": False, "section_name": section_name, "error": str(e)}
    except json.JSONDecodeError as e:
        print(f"JSON parsing error for {section_name}: {e}")
        return {"success": False, "section_name": section_name, "error": f"Failed to parse response: {e}"}
    except Exception as e:
        print(f"Unexpected error during {section_name} extraction: {e}")
        return {"success": False, "section_name": section_name, "error": str(e)}
```

### 5) Complete EHR Integration Pipeline

```python
def process_mixed_medical_document(file_url: str, use_fast_mode: bool = False) -> Dict[str, Any]:
    """
    Complete pipeline: Split document, then extract structured data from each section.
    
    Args:
        file_url: URL to the mixed medical document
        use_fast_mode: Whether to use fast extraction mode
    
    Returns:
        Dictionary containing all extracted EHR data organized by document type
    """
    print(f"\nüè• PROCESSING MIXED MEDICAL DOCUMENT")
    print(f"üìÑ Document: {file_url}")
    print(f"‚ö° Mode: {'Fast' if use_fast_mode else 'Standard'}")
    print("="*60)
    
    # Step 1: Split the document
    print("\nüìã Step 1: Splitting document into sections...")
    split_result = split_medical_document(file_url)
    
    if not split_result.get("success"):
        print("‚ùå Document splitting failed!")
        return {"success": False, "error": "Failed to split document", "details": split_result}
    
    # Step 2: Extract data from each section
    print(f"\nüîç Step 2: Extracting structured data from each section...")
    
    extraction_results = {}
    split_data = split_result["split_result"]
    
    for partition in split_data.get("partitions", []):
        section_name = partition["name"]
        pages = partition.get("pages", [])
        
        if not pages:  # Skip empty partitions
            print(f"‚ö†Ô∏è  Skipping {section_name} (no pages found)")
            continue
            
        # Get the appropriate schema for this document type
        schema = SCHEMA_MAPPING.get(section_name)
        if not schema:
            print(f"‚ö†Ô∏è  No schema defined for {section_name}, skipping...")
            continue
            
        print(f"\n   üìë Processing {section_name} (pages {pages})...")
        
        # Extract structured data
        extraction_result = extract_from_document_section(
            file_url=file_url,
            schema=schema,
            section_name=section_name,
            pages=pages,
            use_fast_mode=use_fast_mode
        )
        
        extraction_results[section_name] = extraction_result
        
        if extraction_result.get("success"):
            print(f"   ‚úÖ Successfully extracted {section_name} data")
        else:
            print(f"   ‚ùå Failed to extract {section_name} data: {extraction_result.get('error')}")
    
    # Step 3: Compile final results
    successful_extractions = sum(1 for result in extraction_results.values() 
                               if result.get("success"))
    
    print(f"\nüìä PROCESSING COMPLETE:")
    print(f"   Document sections found: {len(split_data.get('partitions', []))}")
    print(f"   Successful extractions: {successful_extractions}")
    print(f"   Failed extractions: {len(extraction_results) - successful_extractions}")
    
    return {
        "success": True,
        "document_url": file_url,
        "split_results": split_data,
        "extraction_results": extraction_results,
        "summary": {
            "total_sections": len(split_data.get("partitions", [])),
            "successful_extractions": successful_extractions,
            "processing_mode": "fast" if use_fast_mode else "standard"
        }
    }

def print_ehr_data_summary(processing_result: Dict[str, Any]):
    """Print a formatted summary of extracted EHR data."""
    if not processing_result.get("success"):
        print(f"‚ùå Processing failed: {processing_result.get('error')}")
        return
        
    print(f"\n{'='*60}")
    print("EHR DATA EXTRACTION SUMMARY")
    print("="*60)
    
    extraction_results = processing_result["extraction_results"]
    
    for section_name, result in extraction_results.items():
        if not result.get("success"):
            print(f"\n‚ùå {section_name.upper()}: Extraction failed")
            continue
            
        data = result["data"]
        pages = result.get("pages", [])
        
        print(f"\n‚úÖ {section_name.upper()} (Pages {pages}):")
        
        if section_name == "patient_intake":
            # Patient Demographics
            demo = data.get("patient_demographics", {})
            if demo:
                print(f"   üë§ Patient: {demo.get('first_name', '')} {demo.get('last_name', '')}")
                print(f"   üìÖ DOB: {demo.get('date_of_birth', 'Not found')}")
                print(f"   üìû Phone: {demo.get('phone_number', 'Not found')}")
                
                emergency = demo.get("emergency_contact", {})
                if emergency.get("name"):
                    print(f"   üö® Emergency Contact: {emergency.get('name')} ({emergency.get('relationship')})")
            
            # Medical History
            history = data.get("medical_history", {})
            if history:
                meds = history.get("current_medications", [])
                if meds:
                    print(f"   üíä Medications: {len(meds)} listed")
                    for med in meds[:2]:  # Show first 2
                        print(f"      ‚Ä¢ {med.get('medication_name', 'Unknown')} - {med.get('dosage', 'Unknown dosage')}")
                
                allergies = history.get("allergies", [])
                if allergies:
                    print(f"   ‚ö†Ô∏è  Allergies: {', '.join(allergies[:3])}")
            
            # Chief Complaint
            complaint = data.get("chief_complaint", {})
            if complaint.get("primary_symptoms"):
                print(f"   üè• Chief Complaint: {complaint['primary_symptoms'][:60]}...")
                if complaint.get("pain_level"):
                    print(f"   üìä Pain Level: {complaint['pain_level']}/10")
        
        elif section_name == "insurance_cards":
            insurance = data.get("insurance_info", {})
            if insurance:
                print(f"   üèõÔ∏è Insurance: {insurance.get('insurance_company', 'Not found')}")
                print(f"   üÜî Member ID: {insurance.get('member_id', 'Not found')}")
                print(f"   üë• Group #: {insurance.get('group_number', 'Not found')}")
                
                copays = insurance.get("copay_amounts", {})
                if copays:
                    print(f"   üí≥ Copays: PCP ${copays.get('primary_care', 'N/A')}, Specialist ${copays.get('specialist', 'N/A')}")
        
        elif section_name == "consent_forms":
            consent = data.get("consent_details", {})
            if consent:
                print(f"   üìù Consent Type: {consent.get('consent_type', 'Not found')}")
                print(f"   üìÖ Consent Date: {consent.get('consent_date', 'Not found')}")
                print(f"   üë©‚Äç‚öïÔ∏è Provider: {consent.get('provider_name', 'Not found')}")
            
            hipaa = data.get("hipaa_authorization", {})
            if hipaa.get("authorized_persons"):
                print(f"   üîí HIPAA Authorized: {', '.join(hipaa['authorized_persons'][:2])}")
        
        elif section_name == "referral_letters":
            print(f"   üë©‚Äç‚öïÔ∏è Referring Provider: {data.get('referring_provider', 'Not found')}")
            print(f"   üéØ Referral Reason: {data.get('referral_reason', 'Not found')[:50]}...")
            print(f"   üè• Recommended Specialist: {data.get('recommended_specialist', 'Not found')}")
    
    print("="*60)
```

### 6) Sample Mixed Medical Document

```python
# Sample mixed medical document URLs
SAMPLE_EHR_DOCUMENTS = [
    "https://example-medical-docs.s3.amazonaws.com/mixed_patient_packet.pdf",
    "https://sample-docs.s3.amazonaws.com/ehr/patient_intake_with_insurance.pdf", 
    "https://medical-forms.s3.amazonaws.com/complete_patient_packet.pdf"
]

# For demo purposes - replace with your actual mixed medical document
sample_url = SAMPLE_EHR_DOCUMENTS[0]
print(f"Using sample mixed medical document: {sample_url}")
```

### 7) Run the Complete EHR Integration Pipeline

```python
# Process the mixed medical document
print("üöÄ Starting EHR Integration Pipeline...")

# Process with standard mode for maximum accuracy
ehr_results = process_mixed_medical_document(
    file_url=sample_url,
    use_fast_mode=False  # Use standard mode for EHR accuracy
)

# Display the results
print_ehr_data_summary(ehr_results)

# Also try fast mode for comparison
print(f"\n{'='*30}")
print("üèÉ‚Äç‚ôÇÔ∏è COMPARISON: Fast Mode Processing")
print("="*30)

fast_results = process_mixed_medical_document(
    file_url=sample_url,
    use_fast_mode=True
)

if fast_results.get("success") and ehr_results.get("success"):
    print(f"\nüìä SPEED COMPARISON:")
    standard_sections = len(ehr_results["extraction_results"])
    fast_sections = len(fast_results["extraction_results"]) 
    print(f"   Standard mode: {standard_sections} sections processed")
    print(f"   Fast mode: {fast_sections} sections processed")
    print(f"   Both modes found the same sections: {'‚úÖ' if standard_sections == fast_sections else '‚ùå'}")
```

### 8) Export EHR Data for Integration

```python
import pandas as pd
from datetime import datetime

def export_ehr_data_for_integration(processing_result: Dict[str, Any], 
                                   filename: str = None) -> Dict[str, pd.DataFrame]:
    """
    Export extracted EHR data in formats suitable for EHR system integration.
    
    Args:
        processing_result: Results from process_mixed_medical_document()
        filename: Base filename for exports (will create multiple files)
    
    Returns:
        Dictionary of DataFrames for different data types
    """
    if not processing_result.get("success"):
        print("‚ùå Cannot export - processing was not successful")
        return {}
    
    if filename is None:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"ehr_integration_{timestamp}"
    
    extraction_results = processing_result["extraction_results"]
    dataframes = {}
    
    # Patient Demographics Table
    patient_data = []
    for section_name, result in extraction_results.items():
        if not result.get("success") or section_name != "patient_intake":
            continue
            
        data = result["data"]
        demo = data.get("patient_demographics", {})
        if demo:
            addr = demo.get("address", {})
            emergency = demo.get("emergency_contact", {})
            
            patient_record = {
                "first_name": demo.get("first_name", ""),
                "last_name": demo.get("last_name", ""),
                "date_of_birth": demo.get("date_of_birth", ""),
                "gender": demo.get("gender", ""),
                "street_address": addr.get("street", ""),
                "city": addr.get("city", ""),
                "state": addr.get("state", ""),
                "zip_code": addr.get("zip_code", ""),
                "phone_number": demo.get("phone_number", ""),
                "email": demo.get("email", ""),
                "emergency_contact_name": emergency.get("name", ""),
                "emergency_contact_relationship": emergency.get("relationship", ""),
                "emergency_contact_phone": emergency.get("phone", ""),
                "document_source": processing_result["document_url"]
            }
            patient_data.append(patient_record)
    
    if patient_data:
        dataframes["patient_demographics"] = pd.DataFrame(patient_data)
        print(f"‚úÖ Patient demographics: {len(patient_data)} records")
    
    # Insurance Information Table
    insurance_data = []
    for section_name, result in extraction_results.items():
        if not result.get("success") or section_name != "insurance_cards":
            continue
            
        data = result["data"]
        insurance = data.get("insurance_info", {})
        if insurance:
            copays = insurance.get("copay_amounts", {})
            coverage = data.get("coverage_details", {})
            
            insurance_record = {
                "insurance_company": insurance.get("insurance_company", ""),
                "plan_name": insurance.get("plan_name", ""),
                "member_id": insurance.get("member_id", ""),
                "group_number": insurance.get("group_number", ""),
                "policy_holder_name": insurance.get("policy_holder_name", ""),
                "effective_date": insurance.get("effective_date", ""),
                "primary_care_copay": copays.get("primary_care", ""),
                "specialist_copay": copays.get("specialist", ""),
                "emergency_room_copay": copays.get("emergency_room", ""),
                "deductible": insurance.get("deductible", ""),
                "customer_service_phone": insurance.get("customer_service_phone", ""),
                "in_network_benefits": coverage.get("in_network_benefits", ""),
                "prescription_coverage": coverage.get("prescription_coverage", ""),
                "document_source": processing_result["document_url"]
            }
            insurance_data.append(insurance_record)
    
    if insurance_data:
        dataframes["insurance_information"] = pd.DataFrame(insurance_data)
        print(f"‚úÖ Insurance information: {len(insurance_data)} records")
    
    # Medical History & Medications
    medical_data = []
    for section_name, result in extraction_results.items():
        if not result.get("success") or section_name != "patient_intake":
            continue
            
        data = result["data"]
        history = data.get("medical_history", {})
        
        # Current medications
        medications = history.get("current_medications", [])
        for med in medications:
            med_record = {
                "data_type": "medication",
                "medication_name": med.get("medication_name", ""),
                "dosage": med.get("dosage", ""),
                "frequency": med.get("frequency", ""),
                "category": "current_medication",
                "document_source": processing_result["document_url"]
            }
            medical_data.append(med_record)
        
        # Allergies
        allergies = history.get("allergies", [])
        for allergy in allergies:
            allergy_record = {
                "data_type": "allergy",
                "item": allergy,
                "category": "allergy",
                "document_source": processing_result["document_url"]
            }
            medical_data.append(allergy_record)
        
        # Medical conditions
        conditions = history.get("medical_conditions", [])
        for condition in conditions:
            condition_record = {
                "data_type": "condition",
                "item": condition,
                "category": "medical_condition",
                "document_source": processing_result["document_url"]
            }
            medical_data.append(condition_record)
    
    if medical_data:
        dataframes["medical_history"] = pd.DataFrame(medical_data)
        print(f"‚úÖ Medical history: {len(medical_data)} records")
    
    # Export all DataFrames to CSV
    for table_name, df in dataframes.items():
        csv_filename = f"{filename}_{table_name}.csv"
        df.to_csv(csv_filename, index=False)
        print(f"üìÑ Exported {table_name} to: {csv_filename}")
    
    print(f"\nüìä EXPORT SUMMARY:")
    print(f"   Total tables exported: {len(dataframes)}")
    print(f"   Base filename: {filename}")
    
    return dataframes

# Example usage:
if 'ehr_results' in locals() and ehr_results.get("success"):
    print("\nüíæ EXPORTING EHR DATA FOR INTEGRATION...")
    exported_dfs = export_ehr_data_for_integration(ehr_results)
    
    # Show preview of exported data
    for table_name, df in exported_dfs.items():
        print(f"\nüìã {table_name.upper()} TABLE PREVIEW:")
        print(df.head(2).to_string(index=False)[:200] + "...")
        print(f"   Shape: {df.shape[0]} rows √ó {df.shape[1]} columns")
```


---

## What You Just Built

Congratulations! You've created an intelligent EHR integration system that can split mixed medical documents and extract structured data. Your system can now:

- **Split mixed documents** into patient intake, insurance cards, and consent forms
- **Extract targeted data** using specialized schemas for each document type  
- **Process batch workflows** for multiple patient packets efficiently
- **Export EHR-ready data** in CSV format for seamless integration

Your sample patient packet is just the beginning - imagine processing hundreds of patient documents automatically for instant EHR data entry!